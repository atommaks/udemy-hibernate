# udemy-hibernate

### Введение
Entity таблиц должны быть:
1. Иметь формат _POJO(Plain Old Java Object)_ и иметь соответсвующие Getters & Setters
2. Класс должен быть не финальным, т.к. hibernate активно использует прокси _CGLIB(code generate)_, который наследуется 
от классов
3. Должен иметь дефолтный/пустой конструктор, т.к. hibernate активно использует рефлексию

Hibernate преобразовывает типы реализации entity, используя класс <code>Type</code>. Преобразование своего
кастомного класса можно реализовать чере интерфейс <code>UserType</code>, который в свое время наследуется от
<code>Type</code>. Эту задачу облегчает библиотека <code>Hibernate Types</code>,
т.к. приходится переопределять много методов
<p>У сущности есть есть 4 основных состояния:</p>

1. <i>Transient</i> - когда мы просто создаем класс сущности
2. <i>Persistent</i> - когда мы вызываем методы сохранения/обновления сущности
3. <i>Detached</i> - когда мы работаем с кэшом сессии или когда закрываем сессию
4. <i>Removed</i> - когда мы используем удаление сущности

Сущность имеет свое состояние по отношении только к 1 конкретному контексту сессии `persistenceContext`.
При удалении сущности происходит обращение к общему пулу сессий(метод `get()` у сессии) и состояние меняется на removed.

### Логирование
`Appender` указывает куда в какой класс мы отправляем сообщения, а таргет указывает куда мы их выводим. Формат сообщений
мы указываем с помошью `layout`. Более подробный с лэйаутами можно ознакомиться в 
[документации логгера](https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html).
`root` - это сам логгер, у которого мы указываем уровень логирования.
Уровни логирования: fatal <- error <- warn <- info <- debug <- trace.

### Primary keys. Embedded components
Для того, чтобы можно было использовать составной ключ, класс составного ключа долчен реализовывать интерфейс
`Serializable`(2-ой уровень кэша хибернейта использует сериализацию/десиарилезацию).

### Mapping entity associations

<p>По умолчанию для обычных сущностей(не коллекций) <code>FetchType = EAGER</code>(жадный), т.е. он делает выборку 
внешней сущноститолько тогда, когда мы хотим получить нашу сущность. <code>FetchType = LAZY</code> делает запрос на 
получение внешней сущноститога, когда мы только обращаемся к этой внешней сущности. Изначально при таком типе внешная 
сущность просто обернута в прокси.</p>

<p>Хибернейт-прокси хранит внутри себя сессию, т.к. без нее не получится делать запросы в базу. Если сессия вдруг
закроется, то можно получить <code>LazyInitializationException</code>. При вызове получения внешнего ключа, прокси не
делает запрос базу, т.к. внешний ключ и так хранится в сущности, но если мы попросим другое поле у внешней сущности, то
запрос в базу будет совершен.</p>

<p> <code>CascadeType</code> определяет, что нам делать с внешней сущностью, если состояние текущей сущности поменялось
(см. 4 основных состояние сущности). Нужно быть осторожным при выборе данного параметра. Следует соблюдать принцип
<i>parent->child</i>, т.е. сначала сохраняем главную сущность родителя, а только потом уже все дочерние сущности.</p>

<p> <code>orphanRemoval</code> нужен для того, чтобы определять нужно ли удалять запись из базы при удалении класса
сущности из коллекции.</p>

<p>При <code>OneToOne</code> lazy-инициализация возможно только при настройке параметра <code>optional=true</code>, т.к.
А лучше вообще отказаться от bydirectional зависимости при <code>OneToOne</code></p>
<p>Также лучше использоваться коллекцию <code>List, Collection</code>, а не <code>Set, HashSet</code>. Еще хибернейт
использует свои ListPersistance</p>
<p>Также вместо коллекций можно использовать <code>Map</code> благодаря аннотации <code>@MapKey</code></p>