# udemy-hibernate

## Введение
Entity таблиц должны быть:
1. Иметь формат _POJO(Plain Old Java Object)_ и иметь соответсвующие Getters & Setters
2. Класс должен быть не финальным, т.к. hibernate активно использует прокси _CGLIB(code generate)_, который наследуется 
от классов
3. Должен иметь дефолтный/пустой конструктор, т.к. hibernate активно использует рефлексию

Hibernate преобразовывает типы реализации entity, используя класс <code>Type</code>. Преобразование своего
кастомного класса можно реализовать чере интерфейс <code>UserType</code>, который в свое время наследуется от
<code>Type</code>. Эту задачу облегчает библиотека <code>Hibernate Types</code>,
т.к. приходится переопределять много методов
<p>У сущности есть есть 4 основных состояния:</p>

1. <i>Transient</i> - когда мы просто создаем класс сущности
2. <i>Persistent</i> - когда мы вызываем методы сохранения/обновления сущности
3. <i>Detached</i> - когда мы работаем с кэшом сессии или когда закрываем сессию
4. <i>Removed</i> - когда мы используем удаление сущности

Сущность имеет свое состояние по отношении только к 1 конкретному контексту сессии `persistenceContext`.
При удалении сущности происходит обращение к общему пулу сессий(метод `get()` у сессии) и состояние меняется на removed.

<img src="/src/main/resources/images/entity_lifecycle.png" style="height: 500px; width:1000px;" title="" alt=""/>
<img src="/src/main/resources/images/session_factory.png" style="height: 500px; width:1000px;" title="" alt=""/>
<img src="/src/main/resources/images/session_pool.png" style="height: 450px; width:600px;" title="" alt=""/>

## Логирование
`Appender` указывает куда в какой класс мы отправляем сообщения, а таргет указывает куда мы их выводим. Формат сообщений
мы указываем с помошью `layout`. Более подробный с лэйаутами можно ознакомиться в 
[документации логгера](https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html).
`root` - это сам логгер, у которого мы указываем уровень логирования.
Уровни логирования: fatal <- error <- warn <- info <- debug <- trace.

## Primary keys. Embedded components
Для того, чтобы можно было использовать составной ключ, класс составного ключа долчен реализовывать интерфейс
`Serializable`(2-ой уровень кэша хибернейта использует сериализацию/десиарилезацию).

<img src="/src/main/resources/images/inheritance.png" style="height: 400px; width:1200px;" title="" alt=""/>

## Mapping entity associations

<p>По умолчанию для обычных сущностей(не коллекций) <code>FetchType = EAGER</code>(жадный), т.е. он делает выборку 
внешней сущноститолько тогда, когда мы хотим получить нашу сущность. <code>FetchType = LAZY</code> делает запрос на 
получение внешней сущноститога, когда мы только обращаемся к этой внешней сущности. Изначально при таком типе внешная 
сущность просто обернута в прокси.</p>

<p>Хибернейт-прокси хранит внутри себя сессию, т.к. без нее не получится делать запросы в базу. Если сессия вдруг
закроется, то можно получить <code>LazyInitializationException</code>. При вызове получения внешнего ключа, прокси не
делает запрос базу, т.к. внешний ключ и так хранится в сущности, но если мы попросим другое поле у внешней сущности, то
запрос в базу будет совершен.</p>

<p> <code>CascadeType</code> определяет, что нам делать с внешней сущностью, если состояние текущей сущности поменялось
(см. 4 основных состояние сущности). Нужно быть осторожным при выборе данного параметра. Следует соблюдать принцип
<i>parent->child</i>, т.е. сначала сохраняем главную сущность родителя, а только потом уже все дочерние сущности.</p>

<p> <code>orphanRemoval</code> нужен для того, чтобы определять нужно ли удалять запись из базы при удалении класса
сущности из коллекции.</p>

<p>При <code>OneToOne</code> lazy-инициализация возможно только при настройке параметра <code>optional=true</code>, т.к.
А лучше вообще отказаться от bydirectional зависимости при <code>OneToOne</code></p>
<p>Также лучше использоваться коллекцию <code>List, Collection</code>, а не <code>Set, HashSet</code>. Еще хибернейт
использует свои ListPersistance</p>
<p>Также вместо коллекций можно использовать <code>Map</code> благодаря аннотации <code>@MapKey</code></p>

## Dynamic Queries
<p>Для генерации запросов к БД с непостоянными параметрами можно использовать <code>CriteriaAPI</code>. Получают ее из
сесси <code>session.getCriteriaBuilder()</code>.</p>
<p>Но код с этим API не особо читаемый и удобный в использовании поэтому лучше использовать <code>QueryDSL</code> или 
<code>jOOQ</code></p>

## N + 1 проблема
<p>Вместо одного нужного запроса происходит N дополнительных запросов, что не всегда есть хорошо.</p>
<p>Способы решения N+1:</p>
<ul>
    <li>Использовать <code><b>fetchType = LAZY</b></code>. Использовать ленивую подгрузку внешних сущностей является
    аксиомой, снижающей нагрузку при работе с базой, но такой подход все равно не решается проблемы N + 1.</li>
    <li>Можно использовать <code><b>@BatchSize(n)</b></code>, но это тоже не всегда является решением проблемы, т.к. 
    условно у у нас происходит N + 1 запросов, а так будет происходить N/batchSize + 1 запросов. Также при маппинге один
    к одному использование <code>@BatchSize(n)</code> не даст никаких преимуществ. Также при n->∞ batchSize не дает
    преимуществ.</li>
    <li>Аннотация <code><b>@Fetch</b></code>, у которой есть 3 вида <code>FetchMode</code>:
        <ul>
            <li><code>SELECT</code> - делает просто дополнительный запрос для получения нашей сущности или коллекци. 
            Т.е. по факту ничего не меняется и N+1 проблема все равно останется нерешенной.</li>
            <li><code>JOIN</code> - вместо отдельного запроса делается join, но join также не поможет решить проблему,
            т.к. у нас получается декартовое произведение, и мы не сможем использовать какие-то лимиты, оффсеты, 
            агрегирующие функции.</li>
            <li><code>SUBSELECT</code> - доступен только для коллекций. Делает подзапрос, копируя наш 1-ый запрос, и
            подставляет его в подзапрос для получения зависимых внешних сущностей.</li>
        </ul>
    <code>FetchMode</code><code>SELECT</code>, <code>JOIN</code> лучше использовать при маппинге
    <code>@ManyToOne</code>. С <code>@OneToMany</code> <code>SUBSELECT</code> решает N+1 проблему. Но у 
    <code>FetchMode</code> есть свои недостатки: по факту он работает как <code>fetchType = EAGER</code>, т.к. при 
    загрузке основной сущности мы всегда будет в подзапросе подгружать нашу коллекцию. Таким образом, 
    <code>@Fetch</code> хорош в определенных случаях как и <code>@BatchSize(n)</code>, но все же лучше стараться 
    избегать его использования.</li>
    <li><b>Использовать fetch на уровне SQL/HQL/QueryDSL запроса.</b> В целом, неплохой способ к решению проблемы, 
    который рекомендуется к использованию. Но все равно очень аккуратно.</li>
    <li>Использование аннотации <code><b>@FetchProfile</b></code>. Но такой вариант не работает для SQL/HQL. 
    <code>@FetchProfile</code> лучше использовтаь при работе с одной сущностью</li>
    <li>Использование <code><b>EntityGraph API</b></code>. </li>
</ul>

### Best practises
<ul>
    <li>Избегать<code>@OneToOne</code>bididerctional связей. Его использование допустимо только в случае, если у нас не 
    синтетический ключ, а объектный. Тогда использование<code>optional = false, fetchType = LAZY</code>
    спасает ситуацию.</li>
    <li>Использовать везде <code>fetchType = LAZY</code>.</li>
    <li>Стараться избегать использования <code>@BatchSize, @Fetch</code>.</li>
    <li>Использовать <code>@Fetch</code>.</li>
    <li>Использовать <code>EntityGraph API</code>.</li>
</ul>

## Transactions & Locks
**ACID** - набор свойств, которыми должна обладать каждая БД.
- A — Атомарность (Atomicity). Гарантирует, что никакая транзакция не будет зафиксирована в системе частично. 
- C — Согласованность (Consistency). Каждая успешная транзакция фиксирует только допустимые результаты. 
- I — Изолированность (Isolation). Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на
её результат. 
- D — Стойкость (Durability). Подтверждённые изменения не будут отменены (например, из-за сбоя).

**Проблемы изоляции транзакций**:
- Потерянное обновление(Lost Update) - Происходит, когда обе транзакции одновременно обновляют данные, и затем 2-ая 
транзакция откатывает изменения, вследствиие чего изменения обеих транзакция теряются.
- Грязное чтение (Dirty Read) - Происходит тогда, когда 1-ая транзакция читает изменения, сделанные другой транзакцией, 
но эти изменения еще не были ей закомичены. После чего 2-ая транзакция откатывает эти изменения, а 1-ая продолжает
работать с грязными данными.
- Неповторяющиеся чтение (Non Repeatable Read) - Происходит, когда 1-ая транзакция читает одни и те же данные дважды, но
после 1-ого прочтения 2-ая транзакция изменяет эти же данные и делает коммит, вследствие чего 2-ая выборка в 1-ой
транзакции вернет другой результат.
- Фантомное чтение (Phantom Read) - Происходит, когда 1-ая транзакция читает одни и те же данные дважды, но после 1-ого
прочтения 2-ая транзакция добавляет новые строки или удаляет старые и делает коммит, вследствие чего 2-ая выборка в 1-ой
транзакции вернет другой результат(разное кол-во записей).

**Уровни изолированности транзакций**

<img src="/src/main/resources/images/isolation_level.png" style="height: 220px; width:1000px;" title="" alt=""/>

## Listeners & Interceptors
**Entity Callbacks**

Существует 7 видов коллбэков для сущностей:
- PreUpdate - перед обновлением данных сущности
- PostUpdate - после обновления данных сущности
- PrePersist - перед сохранением сущности
- PostPersist - после сохранения сущности
- PreRemove - перед удалением сущности
- PostRemove - после удаления сущности
- PostLoad - после того как загрузили сущность

У хибернейта есть много своих листенеров на разные события. В список их листенеров можно и добавить свои кастомные. 
Достаточно будет просто реализовать нужные методы от нужных интерфейсов и добавить их в списки.

## Second Level Cache

<img src="/src/main/resources/images/second_level_cache.png" style="height: 780px; width:620px;" title="" alt=""/>