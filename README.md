# udemy-hibernate

### Введение
Entity таблиц должны быть:
1. Иметь формат _POJO(Plain Old Java Object)_ и иметь соответсвующие Getters & Setters
2. Класс должен быть не финальным, т.к. hibernate активно использует прокси _CGLIB(code generate)_, который наследуется 
от классов
3. Должен иметь дефолтный/пустой конструктор, т.к. hibernate активно использует рефлексию

Hibernate преобразовывает типы реализации entity, используя класс <code>Type</code>. Преобразование своего
кастомного класса можно реализовать чере интерфейс <code>UserType</code>, который в свое время наследуется от
<code>Type</code>. Эту задачу облегчает библиотека <code>Hibernate Types</code>,
т.к. приходится переопределять много методов
<p>У сущности есть есть 4 основных состояния:</p>

1. <i>Transient</i> - когда мы просто создаем класс сущности
2. <i>Persistent</i> - когда мы вызываем методы сохранения/обновления сущности
3. <i>Detached</i> - когда мы работаем с кэшом сессии или когда закрываем сессию
4. <i>Removed</i> - когда мы используем удаление сущности

Сущность имеет свое состояние по отношении только к 1 конкретному контексту сессии `persistenceContext`.
При удалении сущности происходит обращение к общему пулу сессий(метод `get()` у сессии) и состояние меняется на removed.

### Логирование
`Appender` указывает куда в какой класс мы отправляем сообщения, а таргет указывает куда мы их выводим. Формат сообщений
мы указываем с помошью `layout`. Более подробный с лэйаутами можно ознакомиться в 
[документации логгера](https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html).
`root` - это сам логгер, у которого мы указываем уровень логирования.
Уровни логирования: fatal <- error <- warn <- info <- debug <- trace.
